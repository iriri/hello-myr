/* basically 100% copied from the documentation but worse */
use std
use thread
use http
use "server"
use "wrappers"
use "../async/async"
use "../chan/chan"

const main = {
	async.init(8)
	match ahttp.announce("tcp!localhost!8080")
	| `std.Ok s: ahttp.serve(s, handler)
	| `std.Err e: std.fatal("unable to announce: {}\n", e)
	;;
}

const handler = {srv, sess, req
	match req.url.path
	| "/ping":  respond(srv, sess, 200, "pong")
	| fspath:   showfile(srv, sess, req.url.path)
	;;
}

const showfile = {srv, sess, path
	var p = std.pathcat(".", path)
	async.exec(async.map(ahttp.slurp(p), {r
		std.slfree(p)
		match r
		| `std.Ok buf:
			respond(srv, sess, 200, buf)
			std.slfree(buf)
		| `std.Err e:
			var eb : byte[128]
			respond(srv, sess, 404, std.bfmt(eb[:], "err: {}\n", e))
		;;
	}))
}


const respond = {srv, sess, status, body
	var resp = std.mk([
		.status=status,
		.hdrs = [][:],
		.len = 0,
		.err = `std.None,
		.reason = "",
		.body = body,
		.enc = `http.Length
	])
	ahttp.respond(srv, sess, resp)
	std.free(resp)
}
