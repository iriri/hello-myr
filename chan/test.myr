use std
use sys
use thread
use "chan"

const Threadc = 16
const Lim = 100000

const main = {
	var c : chan.chan(int64)# = chan.mk(8)

	/* basic test */
	chan.send(c, 1)
	match chan.recv(c)
	| `std.Ok `std.Some i: std.put("received {}\n", i)
	| `std.Ok `std.None: std.die("received nothing\n")
	| `std.Err `chan.Wblock: std.die("would block\n")
	| `std.Err `chan.Closed: std.die("closed\n")
	;;

	/* torture test */
	var sum : int64 = 0
	var sump = &sum
	var done : int32 = 0
	var donep = &done
	for var i = 0; i < Threadc ; i++
		thread.spawn({
			var local_sum : int64 = 0
			for i1 : chan.bymsg(c)
				local_sum += i1
			;;
			std.put("local sum: {}\n", local_sum)
			thread.xadd(sump, local_sum)
			thread.xadd(donep, 1)
		})
	;;
	for var i = 0; i < Threadc ; i++
		var c1 = chan.dup(c)
		thread.spawn({
			var local_sum = 0
			for var i = 1; i <= Lim; i++
				chan.send(c1, i)
			;;
			chan.close(c1)
		})
	;;
	chan.close(c)

	/* tfw no thread.join */
	while thread.xget(donep) < (Threadc : int32)
		sys.sleep(1)
	;;
	std.put("sum:	  {}\n", sum)
	std.put("expected: {}\n", ((Lim * (Lim + 1)) / 2) * Threadc)

	chan.free(c)
}
