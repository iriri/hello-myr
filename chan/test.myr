use std
use sys
use thread
use "chan"

const Threadc = 16
const Lim = 100000

const main = {
	var c = chan.make(1)
	/* var c : chan.chan(int64) = chan.make(1) */ /* doesn't work? */

	/* basic test */
	chan.send(c, 1)
	/* rust-style if/while let syntax would be nice */
	match chan.recv(c)
	| `chan.Ok `std.Some i: std.put("received {}\n", i)
	| `chan.Ok `std.None: std.die("received nothing\n")
	| `chan.Closed: std.die("closed\n")
	;;

	/* torture test */
	var sum : int64 = 0
	var sump = &sum
	var done : int32 = 0
	var donep = &done
	for var i = 0; i < Threadc ; i++
		thread.spawn({
			var local_sum : int64 = 0
			for ; ;
				match chan.recv(c)
				| `chan.Ok `std.Some i1: local_sum += i1
				| `chan.Ok `std.None:
					std.die("received nothing\n")
				| `chan.Closed: break
				;;
			;;
			/* doesn't seem to work?
			for i1 : c
				local_sum += i1
			;;
			*/
			std.put("local sum: {}\n", local_sum)
			thread.xadd(sump, local_sum)
			thread.xadd(donep, 1)
		})
	;;
	for var i = 0; i < Threadc ; i++
		var c1 = chan.dup(c)
		thread.spawn({
			var local_sum = 0
			for var i = 1; i <= Lim; i++
				chan.send(c1, i)
			;;
			chan.close(c1)
		})
	;;
	chan.close(c)

	/* tfw no thread.join */
	while thread.xget(donep) < (Threadc : int32)
		sys.sleep(1)
	;;
	std.put("sum:	  {}\n", sum)
	std.put("expected: {}\n", ((Lim * (Lim + 1)) / 2) * Threadc)

	chan.drop(c)
}
