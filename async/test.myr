use std
use thread
use "../chan/chan"
use "async"

const main = {
	async.init(4)

	/* kill me now */
	var f = async.bind( \
		async.bind( \
			async.bind(async.return("one\n"), {a
				std.usleep(100_000)
				std.put(a)
				-> async.return(3)
			}), {a
			std.usleep(200_000)
			std.put("{}\n", a)
			-> async.return("five\n")
		}), {a
		std.usleep(200_000)
		std.put(a)
		std.usleep(200_000)
		-> async.return(7)
	})

	var f1 = async.bind( \
		async.bind( \
			async.bind(async.return("two\n"), {a
				std.usleep(200_000)
				std.put(a)
				-> async.return(4)
			}), {a
			std.usleep(200_000)
			std.put("{}\n", a)
			-> async.return("six\n")
		}), {a
		std.usleep(200_000)
		std.put(a)
		std.usleep(200_000)
		-> async.return(8)
	})

	/* i guess this is marginally better
	var f = async.return("one\n") >| async.bind({a
		std.usleep(100_000)
		std.put(a)
		-> async.return(2)
	}) >| async.bind({a
		std.usleep(100_000)
		std.put(a)
		-> async.return("three\n")
	}) >| async.bind({a
		std.usleep(100_000)
		std.put(a)
		-> async.return(4)
	})
	*/

	async.exec(f)
	async.exec(f1)
	std.put("zero\n")
	std.put("{}\n", async.wait(f))
	std.put("{}\n", async.wait(f1))

	std.free(f)
	std.free(f1)
}
