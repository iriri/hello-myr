use std
use thread
use "../chan/chan"
use "async"

const main = {
	async.init(3)

	/* kill me now */
	var f = async.bind( \
		async.bind( \
			async.bind(async.return("one\n"), {a
				std.usleep(100_000)
				std.put(a)
				-> async.return(3)
			}), {a
			std.usleep(200_000)
			std.put("{}\n", a)
			-> async.return("five\n")
		}), {a
		std.usleep(200_000)
		std.put(a)
		std.usleep(200_000)
		-> async.return(7)
	})

	var f1 = async.map( \
		async.map( \
			async.bind(async.return("two\n"), {a
				std.usleep(200_000)
				std.put(a)
				-> async.return(4)
			}), {a
			std.usleep(200_000)
			std.put("{}\n", a)
			-> "six\n"
		}), {a
		std.usleep(200_000)
		std.put(a)
		std.usleep(200_000)
		-> 8
	})

	/* i guess this is marginally better
	var f = async.return("one\n") >| async.bind({a
		std.usleep(100_000)
		std.put(a)
		-> async.return(2)
	}) >| async.bind({a
		std.usleep(100_000)
		std.put(a)
		-> async.return("three\n")
	}) >| async.bind({a
		std.usleep(100_000)
		std.put(a)
		-> async.return(4)
	})
	*/

	// async.force(f)
	async.exec(f)
	async.exec(f1)
	std.put("zero\n")
	std.put("{}\n", async.wait(f))
	for ; ;
		match async.peek(f1)
		| `std.Some v:
			std.put("{}\n", v)
			break
		| `std.None:
			std.put("and again\n")
			std.usleep(50_000)
		;;
	;;

	std.free(f)
	std.free(f1)
}
