use std
use thread
use "../chan/chan"
use "async"

const main = {
	async.init(3)

	/* kill me now */
	var f = async.exec(async.bind( \
		async.bind( \
			async.bind(async.return("one\n"), {a
				std.usleep(100_000)
				std.put(a)
				-> async.return(3)
			}), {a
			std.usleep(200_000)
			std.put("{}\n", a)
			-> async.return("five\n")
		}), {a
		std.usleep(200_000)
		std.put(a)
		std.usleep(200_000)
		-> async.return(7)
	}))

	var f1 = async.exec(async.map( \
		async.map( \
			async.bind(async.return("two\n"), {a
				std.usleep(200_000)
				std.put(a)
				-> async.return(4)
			}), {a
			std.usleep(200_000)
			std.put("{}\n", a)
			-> "six\n"
		}), {a
		std.usleep(200_000)
		std.put(a)
		std.usleep(200_000)
		-> 8
	}))

	std.put("zero\n")
	std.put("{}\n", async.wait(f))
	for ; ;
		match async.peek(f1)
		| `std.Some v:
			std.put("{}\n", v)
			break
		| `std.None:
			std.put("and again\n")
			std.usleep(50_000)
		;;
	;;

	std.free(f)
	std.free(f1)
}
