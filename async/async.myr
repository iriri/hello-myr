use std
use thread
use "../chan/chan"

pkg async =
	type future(@a) = struct
		next : (-> void)
		chan : chan.chan((-> void))
		ready : thread.sem
		val : @a
	;;

	const init : (thrc : uint32 -> void)
	generic spawn : (fn : (-> void) -> void)

	generic exec : (fut : future(@a)# -> future(@a)#)
	generic force : (fut : future(@a)# -> future(@a)#)
	generic fire : (fut : future(@a)# -> void)

	generic wait : (fut : future(@a)# -> @a)
	generic peek : (fut : future(@a)# -> std.option(@a))

	generic map : (fut : future(@a)#, fn : (a : @a -> @b) -> future(@b)#)
	generic bind : (fut : future(@a)#, fn : (a : @a -> future(@b)#) -> future(@b)#)
	generic return : (a : @a -> future(@a)#)
;;

var sched : struct
	later : chan.chan((-> void))
	now : chan.chan((-> void))
	sem : thread.sem
	ready : bool
;; = [.sem = [._val = 1]]

const init = {thrc
	std.assert(thrc > 0, "don't do this to yourself\n")
	thread.semwait(&sched.sem)
	if !sched.ready
		sched.later = chan.mk(thrc - 1)
		sched.now = chan.mk(0)
		for var i = 0; i < thrc; i++
			thread.spawn({
				for f : chan.bymsg(sched.later)
					f()
					std.fnfree(f)
				;;
			})
		;;
		sched.ready = true
	;;
	thread.sempost(&sched.sem)
}

generic spawn = {fn; chan.send(sched.later, std.fndup(fn))}

generic exec = {fut
	fut.chan = sched.later
	chan.send(sched.later, fut.next)
	-> fut
}

generic force = {fut
	fut.chan = sched.now
	fut.next()
	-> fut
}

generic fire = {fut
	fut.chan = sched.later
	chan.send(sched.later, std.fndup({
		fut.next()
		std.fnfree(fut.next)
		std.free(fut)
	}))
}

generic wait = {fut; thread.semwait(&fut.ready); -> fut.val}

generic peek = {fut; -> thread.semtrywait(&fut.ready) ? `std.Some fut.val : `std.None}

generic map = {fut, fn
	var fut1 = std.zalloc()
	fut1.next = std.fndup({
		fut.chan = fut1.chan
		fut.next()
		thread.semwait(&fut.ready)
		var f = std.fndup({
			fut1.val = fn(fut.val)
			std.free(fut)
			thread.sempost(&fut1.ready)
		})
		match chan.trysend(fut.chan, f) // it's like round robin but worse
		| `std.Err _:
			f();
			std.fnfree(f)
		| `std.Ok _:
		;;
	})
	-> fut1
}

generic bind = {fut, fn
	var fut1 = std.zalloc()
	fut1.next = std.fndup({
		fut.chan = fut1.chan
		fut.next()
		thread.semwait(&fut.ready)
		var f = std.fndup({
			fut1.val = wait(fn(fut.val))
			std.free(fut)
			thread.sempost(&fut1.ready)
		})
		match chan.trysend(fut.chan, f)
		| `std.Err _:
			f();
			std.fnfree(f)
		| `std.Ok _:
		;;
	})
	-> fut1
}

generic return = {a; -> std.mk([.next = {;}, .ready = thread.mksem(1), .val = a])}
