use std
use thread

pkg channel =
    type cell = struct
        lap : uint32
        elt : int /* tfw no parameterized types */
    ;;

    type channel = struct
        cap : uint32
        refc : uint32
        write : uint64
        read : uint64
        buf : cell[...]
    ;;

    /* just these two for now */
    const Ok : int = 0
    const Closed : int = 1

    const make : (cap: uint32 -> channel#)
    const drop : (c: channel# -> void)
    const dup : (c: channel# -> channel#)
    const close : (c: channel# -> void)
    const send : (c: channel#, i: int -> int)
    const recv : (c: channel# -> (int, int))
;;


const make = {cap: uint32
    /* how do i break long lines? */
    var c = (std.zbytealloc(sizeof(channel) + ((cap : std.size) * sizeof(int))) : channel#)
    /* null, nil, and none all don't appear in the standard? what do
     * allocations return on failure then? */
    c# = [.cap = cap, .refc = 1, .read = 1 << 32]
    -> c
}

/* it seems method syntax is not a thing? impl blocks seem to be only used for
 * traits. tbh this is totally fine b/c i don't even particularly like method
 * syntax */
const drop = {c: channel#
    std.bytefree((c : byte#), sizeof(channel) + ((c.cap : std.size) * sizeof(int)))
}

const dup = {c: channel#
    thread.xadd(&c.cap, 1) /* tfw no xsub */
    -> c /* this part seems to not work */
}

const close = {c: channel#
    thread.xadd(&c.cap, -1) /* tfw no xsub */
}

const send = {c: channel#, i: int
    for ; ; /* is this the right way to do an infinite loop? */
        if thread.xget(&c.refc) == 0
            -> Closed
        ;;

        var write = thread.xget(&c.write) /* not const? */
        var index = (write : uint32)
        var lap = (write >> 32 : uint32)
        var cell_lap = thread.xget(&c.buf[index].lap)
        if lap != cell_lap
            continue
        ;;

        var write1 = (write : uint32) + 1 < c.cap ? write + 1 : ((lap + 2) << 32 : uint64)
        if thread.xcas(&c.write, write, write1) == write /* should this return a bool? */
            c.buf[index].elt = i
            thread.xset(&c.buf[index].lap, lap + 1)
            -> Ok
        ;;
    ;;
    -> Closed /* unreachable */
}

const recv = {c: channel#
    for ; ;
        var read = thread.xget(&c.read)
        var index = (read : uint32)
        var lap = (read >> 32 : uint32)
        var cell_lap = thread.xget(&c.buf[index].lap)
        if lap != cell_lap
            if thread.xget(&c.refc) == 0
                -> (0, Closed)
            ;;
            continue
        ;;

        var read1 = (read : uint32) + 1 < c.cap ? read + 1 : ((lap + 2) << 32 : uint64)
        if thread.xcas(&c.read, read, read1) == read
            thread.xset(&c.buf[index].lap, lap + 1)
            -> (c.buf[index].elt, Ok)
        ;;
    ;;
    -> (0, Closed) /* unreachable */
}
