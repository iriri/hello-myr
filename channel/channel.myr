use std
use thread

pkg channel =
    type cell(@a) = struct
        lap : uint32
        elt : @a
    ;;

    type channel(@a) = struct
        cap : uint32
        refc : uint32
        write : uint64
        read : uint64
        buf : cell(@a)[...]
    ;;

    type rc(@a) = union
        `Ok std.option(@a)
        /* `Wblock */
        /* `Timedout */
        `Closed
    ;;

    generic make : (cap: uint32 -> channel(@a)#)
    generic drop : (c: channel(@a)# -> void)
    generic dup : (c: channel(@a)# -> channel(@a)#)
    generic close : (c: channel(@a)# -> void)
    generic send : (c: channel(@a)#, elt: @a -> rc(@a))
    generic recv : (c: channel(@a)# -> rc(@a))
;;


generic make = {cap: uint32
    /* how do i break long lines? */
    var c = (std.zbytealloc(sizeof(channel(@a)) + ((cap : std.size) * sizeof(cell(@a)))) : channel(@a)#)
    /* how do allocations fail? */
    c# = [.cap = cap, .refc = 1, .read = 1 << 32]
    -> c
}

generic drop = {c: channel(@a)#
    std.bytefree((c : byte#), sizeof(channel(@a)) + ((c.cap : std.size) * sizeof(cell(@a))))
}

generic dup = {c: channel(@a)#
    thread.xadd(&c.refc, 1)
    -> c
}

generic close = {c: channel(@a)#
    thread.xadd(&c.refc, -1) /* tfw no xsub */
}

generic send = {c: channel(@a)#, elt: @a
    for ; ; /* is this the right way to do an infinite loop? */
        if thread.xget(&c.refc) == 0
            -> `Closed
        ;;

        var write = thread.xget(&c.write) /* not const? */
        var index = (write : uint32)
        var lap = (write >> 32 : uint32)
        var cell_lap = thread.xget(&c.buf[index].lap)
        if lap != cell_lap
            continue
        ;;

        var write1 = index + 1 < c.cap ? write + 1 : ((lap + 2 : uint64) << 32)
        if thread.xcas(&c.write, write, write1) == write
            c.buf[index].elt = elt
            thread.xset(&c.buf[index].lap, lap + 1)
            -> `Ok `std.None
        ;;
    ;;
    -> `Closed /* unreachable */
}

generic recv = {c: channel(@a)#
    for ; ;
        var read = thread.xget(&c.read)
        var index = (read : uint32)
        var lap = (read >> 32 : uint32)
        var cell_lap = thread.xget(&c.buf[index].lap)
        if lap != cell_lap
            if thread.xget(&c.refc) == 0
                -> `Closed
            ;;
            continue
        ;;

        var read1 = index + 1 < c.cap ? read + 1 : ((lap + 2 : uint64) << 32)
        if thread.xcas(&c.read, read, read1) == read
            var elt = c.buf[index].elt
            thread.xset(&c.buf[index].lap, lap + 1)
            -> `Ok `std.Some elt
        ;;
    ;;
    -> `Closed /* unreachable */
}
