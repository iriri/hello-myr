use std
use sys
use thread
use "channel"

const Threadc = 1
const Lim = 100000

const main = {
    var c = channel.make(16)

    /* basic test */
    channel.send(c, 1)
    channel.send(c, 2)
    match channel.recv(c) /* rust-style if/while let syntax would be nice */
    | (i, channel.Ok): std.put("{}\n", i)
    | (_, channel.Closed): std.put("closed\n")
    ;;
    match channel.recv(c)
    | (i, channel.Ok): std.put("{}\n", i)
    | (_, channel.Closed): std.put("closed\n")
    ;;

    /* torture test */
    var sum : int64 = 0
    var sump = &sum
    var done : int32 = 0
    var donep = &done
    for var i = 0; i < Threadc ; i++
        channel.dup(c)
        thread.spawn({
            /* var c = channel.dup(c) */ /* seems broken */
            var local_sum = 0
            var prev = 0
            for ; ;
                match channel.recv(c)
                | (i1, channel.Ok):
                    local_sum += i1
                    if i1 - 1 != prev
                        std.put("i: {}, prev: {}\n", i1, prev)
                    ;;
                    prev = i1
                | (_, channel.Closed): break
                ;;
            ;;
            std.put("local sum: {}\n", local_sum)
            thread.xadd(sump, (local_sum : int64))
            thread.xadd(donep, 1)
        })
    ;;
    for var i = 0; i < Threadc ; i++
        thread.spawn({
            var local_sum = 0
            for var i = 1; i <= Lim; i++
                channel.send(c, i)
            ;;
            channel.close(c)
        })
    ;;
    channel.close(c)

    /* tfw no thread.join */
    while thread.xget(donep) < Threadc
        sys.sleep(1)
    ;;
    std.put("sum:      {}\n", sum) /* needs more fencing? */
    std.put("expected: {}\n", ((Lim * (Lim - 1)) / 2) * (Threadc : int))

    channel.drop(c)
}
