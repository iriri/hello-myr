use std
use sys
use thread
use "channel"

const Threadc = 16
const Lim = 100000

const main = {
    var c = channel.make(1)
    /* var c : channel(int64) = channel.make(1) */ /* doesn't work */

    /* basic test */
    channel.send(c, 1)
    match channel.recv(c) /* rust-style if/while let syntax would be nice */
    | `channel.Ok `std.Some i: std.put("received {}\n", i)
    | `channel.Ok `std.None: std.put("received nothing\n")
    | `channel.Closed: std.put("closed\n")
    ;;

    /* torture test */
    var sum : int64 = 0
    var sump = &sum
    var done : int32 = 0
    var donep = &done
    for var i = 0; i < Threadc ; i++
        thread.spawn({
            var local_sum : int64 = 0
            for ; ;
                match channel.recv(c)
                | `channel.Ok `std.Some i1: local_sum += i1
                | `channel.Ok `std.None: std.put("received nothing\n")
                | `channel.Closed: break
                ;;
            ;;
            std.put("local sum: {}\n", local_sum)
            thread.xadd(sump, local_sum)
            thread.xadd(donep, 1)
        })
    ;;
    for var i = 0; i < Threadc ; i++
        var c1 = channel.dup(c)
        thread.spawn({
            var local_sum = 0
            for var i = 1; i <= Lim; i++
                channel.send(c1, i)
            ;;
            channel.close(c1)
        })
    ;;
    channel.close(c)

    /* tfw no thread.join */
    while thread.xget(donep) < (Threadc : int32)
        sys.sleep(1)
    ;;
    std.put("sum:      {}\n", sum) /* needs more fencing? */
    std.put("expected: {}\n", ((Lim * (Lim + 1)) / 2) * Threadc)

    channel.drop(c)
}
