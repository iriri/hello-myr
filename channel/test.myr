use std
use sys
use thread
use "channel"

const Threadc = 16
const Lim = 100000

const main = {
    var c = channel.make(1)

    /* basic test */
    channel.send(c, 1)
    match channel.recv(c) /* rust-style if/while let syntax would be nice */
    | (i, channel.Ok): std.put("{}\n", i)
    | (_, channel.Closed): std.put("closed\n")
    ;;

    /* torture test */
    var sum : int64 = 0
    var sump = &sum
    var done : int32 = 0
    var donep = &done
    for var i = 0; i < Threadc ; i++
        thread.spawn({
            var local_sum : int64 = 0
            for ; ;
                match channel.recv(c)
                | (i1, channel.Ok): local_sum += (i1 : int64)
                | (_, channel.Closed): break
                ;;
            ;;
            std.put("local sum: {}\n", local_sum)
            thread.xadd(sump, (local_sum : int64))
            thread.xadd(donep, 1)
        })
    ;;
    for var i = 0; i < Threadc ; i++
        var c1 = channel.dup(c)
        thread.spawn({
            var local_sum = 0
            for var i = 1; i <= Lim; i++
                channel.send(c1, i)
            ;;
            channel.close(c1)
        })
    ;;
    channel.close(c)

    /* tfw no thread.join */
    while thread.xget(donep) < Threadc
        sys.sleep(1)
    ;;
    std.put("sum:      {}\n", sum) /* needs more fencing? */
    std.put("expected: {}\n", (((Lim : int64) * ((Lim : int64) + 1)) / 2) * (Threadc : int64))

    channel.drop(c)
}
